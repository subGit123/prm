# 포인터

메모리는 주소를 통해 메모리에 접근하여 값을 읽고 쓸 수 있다.

포인터는 **메모리의 주소값을 저장하고 있는 변수**

주소값을 저장 = 해당 메모리를 가리킴

## 사용법

- `*` 붙이기 : 주소값을 저장한다는 의미

```c
char *pA;
int *pB;
```

- `&` : 주소값을 얻는다는 의미

```c
int *pB = &a;
```

---

## 포인터와 배열

배열의 첫 번째 요소의 주소값을 갖는다

arr = &arr[0]과 일치

---

## 함수와 포인터

배열형의 인자는 포인터형으로 받는다

주소값을 넘겨 받기 위해서는 포인터 형태로 받아야 하기 때문!!

```c
void func(int *pArr){
    ...
}
```

---

## 함수 포인터

함수명 앞에 \*를 붙여주면 함수 포인터가 선언

```c
int (*func)(int a);
```

- 사용 이유
  - 프로그램의 **유연한 확장성**을 위함!!
  - 메모리 절약 : 여러 함수를 하나의 포인터 배열로 관리할 수 있음

---

## 구조체 struct

하나 이상의 서로 다른 종류의 변수들을 묶어서 새로운 데이터 타입을 정의하는 것

- 사용 이유

  - 데이터 관리에 유용함
  - 연관된 변수들을 하나로 묶어 관리하기 때문

- 기본 형태

```c
struct students{
  char name[10]
  int age
  int height
}st1

st1.name , st1.age , st1.height
```

---

## 공용체 union

구조체와 비슷하지만 메모리 공간을 공유함

```c
union unTmp{
  char a;
  int b;
  double c;
}un;
```

---

## 메모리 구조

코드영역 : 실행할 명령어들이 순서대로 쌓임 , cpu가 명령어들을 하나씩 처리

스택영역 : 지역변수 및 매개변수 등등 스택 메모리 사용

```c
void test(int a){
  char b;
  int c;
  double d;
}

// 스택 영역에 a , b , c , d 순으로 쌓이고 d부터 실행
```

힙영역 (동적 메모리): 실행 시 사용자로부터 할당 메모리를 입력 받음

-> 프로그램 종료 시 소멸

동적으로 메모리를 할당하는 이유

- 메모리 할당의 크기를 모르기 때문에 컴파일 타임에 메모리 할당을 받아서
  사용함
